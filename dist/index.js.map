{"version":3,"file":"index.js","sources":["../src/random-number-generators/JavascriptRandom.ts","../src/parsers/RollsProvider.ts","../src/utils/peaks.ts","../src/utils/sum.ts","../src/parsers/Parser.ts","../src/index.ts"],"sourcesContent":["import type {RandomIntegerParamsType} from '../types'\n\nconst getRandomInclusive = (min: number, max: number): number => Math.floor(Math.random() * (max - min + 1) + min)\nexport const getRandomIntegers = ({num = 20, min = 1, max = 20}: RandomIntegerParamsType = {}): number[] => Array.from({length: num}, () => getRandomInclusive(min, max))\n","import {getRandomIntegers} from '../random-number-generators/JavascriptRandom'\nimport {ExplodeUntilTypes, RerollCondition} from \"../types\";\n\nconst diceRollsCache: Map<number, number[]> = new Map<number, number[]>()\n\nconst hasCache = (id: number): boolean => diceRollsCache.has(id) && !!diceRollsCache.get(id)?.length\nconst addToCache = (id: number, values: number[]): number | undefined => {\n  const newValues = [...values]\n\n  const value = newValues.pop()\n  diceRollsCache.set(id, newValues)\n\n  return value\n}\nconst getFromCache = (id: number): number | undefined => {\n  if (!hasCache(id)) return undefined\n\n  const values: number[] = [...(diceRollsCache.get(id) || [])]\n  const value = values.pop()\n\n  diceRollsCache.set(id, values)\n  return value\n}\n\nexport const getDiceRoll = (dice: number): number => {\n  const isCached: boolean = hasCache(dice)\n  if (isCached) return getFromCache(dice) as number\n\n  const generatedValues: number[] = getRandomIntegers({max: dice})\n  return addToCache(dice, generatedValues) as number\n}\nexport const getMultipleDiceRolls = (num: number, dice: number): number[] => Array.from({length: num}, () => getDiceRoll(dice))\n\nexport const getDiceRollUntil = (dice: number, targetType: ExplodeUntilTypes, target: number, outArray: number[] = []): number[] => {\n  const diceValue = getDiceRoll(dice);\n  const iterations = [...outArray, diceValue];\n  switch (targetType) {\n    case \"<\":\n      if (diceValue >= target) return iterations\n      return getDiceRollUntil(dice, targetType, target, iterations)\n    case \">\":\n      if (diceValue <= target) return iterations\n      return getDiceRollUntil(dice, targetType, target, iterations)\n    case \"=\":\n      if (diceValue === target) return getDiceRollUntil(dice, targetType, target, iterations)\n      return iterations\n    case \"o\":\n      if (diceValue === target) return [diceValue, getDiceRoll(dice)] as number[]\n      return iterations\n  }\n}\n\nexport const getMultipleDiceRollsUntil = (dice: number, targetType: ExplodeUntilTypes, target: number, count: number) => {\n  let out: number[] = []\n  for (let i = 0; i < count; i++) {\n    out = [...out, ...getDiceRollUntil(dice, targetType, target)]\n  }\n  return out\n}\n\nexport const rollMatchesTarget = (rolledValue: number, condition: RerollCondition, target: number) => {\n  switch (condition) {\n    case \"=\":\n      return rolledValue === target;\n    case \">\":\n      return rolledValue > target;\n    case \"<\":\n      return rolledValue < target;\n    case \"<=\":\n      return rolledValue <= target;\n    case \">=\":\n      return rolledValue >= target;\n    case \"even\":\n      return rolledValue % 2 === 0\n    case \"odd\":\n      return rolledValue % 2 === 1\n  }\n}\n\nexport const rerollDice = (rolledValues: number[], rerollCondition: RerollCondition, rerollTarget: number, diceType: number) => {\n  const rerolledDice = []\n  const diceToSum = [...rolledValues]\n  for (const rolledValueKey in rolledValues) {\n    if (rollMatchesTarget(rolledValues[rolledValueKey], rerollCondition, rerollTarget)) {\n      const newRoll = getDiceRoll(diceType)\n      rerolledDice.push(newRoll)\n      diceToSum[rolledValueKey] = newRoll\n    }\n  }\n  return [rerolledDice, diceToSum]\n}\n\nexport const recursiveRerollDice = (rolledValues: number[], rerollCondition: RerollCondition, rerollTarget: number, diceType: number) => {\n  const rerolledValues = [...rolledValues]\n  let diceToSum = [...rolledValues]\n\n  for (const diceToSumKey in diceToSum) {\n    while (rollMatchesTarget(diceToSum[diceToSumKey], rerollCondition, rerollTarget)) {\n      const newRoll = getDiceRoll(diceType)\n      rerolledValues.push(newRoll)\n      diceToSum[diceToSumKey] = newRoll\n    }\n  }\n\n  return [rerolledValues, diceToSum]\n}\n\nexport const countDice = (die: number, condition: RerollCondition, countType: string, target?: number, hasDifficulty?: boolean, difficultyCondition?: RerollCondition, difficultyTarget?: number): number => {\n  const difficultyModifier = Number(rollMatchesTarget(die, difficultyCondition ?? '=', difficultyTarget ?? 0))\n  \n  if (countType === 'cs' || countType === 'cf')\n    return Math.max(Number(rollMatchesTarget(die, condition ?? '=', target ?? 0)) - difficultyModifier, -1)\n  if (countType === 'odd' || countType === 'even')\n    return Math.max(Number(rollMatchesTarget(die, countType, 0)) - difficultyModifier, -1)\n\n  return die\n}\n\nexport const explodeArray = (dice: number[], condition: RerollCondition, target: number, diceType: number) => {\n  const explodedArray = [...dice]\n\n  dice.forEach((die) => {\n    if (rollMatchesTarget(die, condition as RerollCondition, target))\n      explodedArray.push(getDiceRoll(diceType))\n  })\n\n  return explodedArray\n}\n","export const findSmallestN = (array: number[], count: number) => {\n    array.sort((a, b) =>  a - b);\n\n    return array.slice(0, count);\n}\n\nexport const findGreatestN = (array: number[], count: number) => {\n    array.sort((a, b) =>  b - a);\n\n    return array.slice(0, count);\n}","export const sumArray = (array: number[]) => array.reduce((res, num) => res + num, 0)","import type {ParseResultType, RerollCondition, ParsedDiceResultType} from '../types'\nimport {\n  getMultipleDiceRolls,\n  getMultipleDiceRollsUntil, recursiveRerollDice,\n  rerollDice, countDice, rollMatchesTarget, getDiceRoll, explodeArray\n} from './RollsProvider'\nimport {\n  DiceKeepTypes,\n  ExplodeMap,\n  ExplodeTypes,\n  ExplodeUntilTypes,\n  MinMaxTypes,\n  DiceParserMappingFunction\n} from \"../types\";\nimport {findGreatestN, findSmallestN} from \"../utils/peaks\";\nimport {sumArray} from \"../utils/sum\";\n\nconst ALL_TYPES_OF_DICE_REGEX = /(?:\\d+d\\d+)(?:rr|r|xo|x|kh|kl|dh|dl|k|d|sf|min|max|even|odd|cs|cf)?(?:>=|<=|>|<|=)?(\\d)*(df|x)?(>=|<=|>|<|=)?(\\d+)?(kh|kl|dh|dl|k|d)?/gim\nconst REROLL_DICE_REGEX = /^(\\d+)d(\\d+)(rr|r)(>=|<=|>|<)?(\\d+)$/gim\nconst EXPLODING_DICE_REGEX = /^(\\d+)d(\\d+)(x<|x>|xo|x)(\\d+)(kh|kl|dh|dl|k|d|min|max)?(\\d+)?$/gim\nconst COUNT_DICE_REGEX = /^(\\d+)d(\\d+)(cs|cf|even|odd)(>=|<=|>|<|=)?(\\d+)?(df|x)?(>=|<=|>|<|=)?(\\d+)?$/gim\nconst CONDITIONAL_SUBTRACT_REGEX = /^(\\d+)d(\\d+)(sf)(>=|<=|>|<|=)?(\\d+)$/gim\nconst STANDARD_DICE_REGEX = /^(\\d+)d(\\d+)(kh|kl|dh|dl|k|d|min|max|)?(\\d+)?$/gim\n\nconst explodeToSignMap: ExplodeMap = {\n  x: '=',\n  'x<': '<',\n  'x>': '>',\n  'xo': 'o'\n}\n\nexport const keepDice = (keepType: DiceKeepTypes, keepCount: number, diceRolls: number[]) => {\n  if (keepType === 'kh' || keepType === 'k') return findGreatestN(diceRolls, keepCount)\n  if (keepType === 'kl') return findSmallestN(diceRolls, keepCount)\n  if (keepType === 'dh') return findSmallestN(diceRolls, diceRolls.length - keepCount)\n  if (keepType === 'dl') return findGreatestN(diceRolls, diceRolls.length - keepCount)\n\n  return diceRolls\n}\n\nexport const applyMinMax = (modifierType: MinMaxTypes, modifierCap: number, diceRolls: number[]) => {\n  if (modifierType === 'min') return diceRolls.map((roll) => roll <= modifierCap ? modifierCap : roll)\n  if (modifierType === 'max') return diceRolls.map((roll) => roll >= modifierCap ? modifierCap : roll)\n\n  return diceRolls\n}\n\nexport const applyEndModifiers = (modifier: DiceKeepTypes | MinMaxTypes, target: number = 1, diceRolls: number[]) => {\n  return applyMinMax(modifier as MinMaxTypes, target, keepDice(modifier as DiceKeepTypes, target, diceRolls))\n}\n\nexport const getRerollValues = (rolledValues: number[], rerollCondition: RerollCondition, rerollTarget: number, diceType: number, rerollType: string) => {\n  if (rerollType === 'r') return rerollDice(rolledValues, rerollCondition as RerollCondition ?? '=', rerollTarget, diceType)\n  if (rerollType === 'rr') return recursiveRerollDice(rolledValues, rerollCondition as RerollCondition ?? '=', rerollTarget, diceType)\n\n  return [[], rolledValues]\n}\n\nexport const parseOriginalString = (parsedObj: ParseResultType): ParseResultType => {\n  const {parsed, results} = parsedObj\n  let parsedWithResults = parsed\n\n  let lengthChanged = 0\n  for (let i = 0; i < results.length; i++) {\n    const res = results[i];\n    const {m, result, start, end} = res\n\n    if (typeof result === 'undefined') continue\n    parsedWithResults = parsedWithResults.substring(0, start - lengthChanged)\n      + result\n      + parsedWithResults.substring(end - lengthChanged, parsedWithResults.length)\n\n    lengthChanged += m.length - `${result}`.length\n  }\n  return {...parsedObj, parsed: parsedWithResults}\n}\n\nexport const countDiceParser = (result: ParsedDiceResultType): ParseResultType => {\n  const {m} = result\n  if (!m.match(COUNT_DICE_REGEX)) return result\n\n  const [_, numberOfDiceString, diceValueString, countType, condition, targetNumberString, difficulty, difficultyCondition, difficultyTarget] = COUNT_DICE_REGEX.exec(m) as RegExpExecArray\n  const numberOfDice = Number(numberOfDiceString)\n  const diceValue = Number(diceValueString)\n  const targetNumber = Number(targetNumberString);\n  const difficultyTargetNumber = Number(difficultyTarget);\n\n  let diceRolls = getMultipleDiceRolls(numberOfDice, diceValue)\n  let countedDice\n\n  if (difficulty === 'x') {\n    diceRolls = explodeArray(diceRolls, condition as RerollCondition, difficultyTargetNumber, diceValue)\n\n    countedDice = Math.abs(diceRolls.reduce((acc, cur) =>\n      acc + countDice(cur, condition as RerollCondition, countType, targetNumber, !!difficulty, \"=\", -1), 0))\n  } else {\n    countedDice = Math.abs(diceRolls.reduce((acc, cur) =>\n      acc + countDice(cur, condition as RerollCondition, countType, targetNumber, !!difficulty, difficultyCondition as RerollCondition, difficultyTargetNumber), 0))\n  }\n\n  return {\n    ...result,\n    rolls: diceRolls,\n    result: countType === 'cs' ? countedDice : diceRolls.length - countedDice,\n    successes: countedDice,\n    fails: diceRolls.length - countedDice\n  }\n}\n\nexport const explodingDiceParser = (result: ParsedDiceResultType): ParseResultType => {\n  const {m} = result\n  if (!m.match(EXPLODING_DICE_REGEX)) return result\n\n  const [_, numberOfDiceString, diceValueString, explodeType, targetNumberString, keepType, keepCount] = EXPLODING_DICE_REGEX.exec(m) as RegExpExecArray\n  const numberOfDice = Number(numberOfDiceString)\n  const diceValue = Number(diceValueString)\n  const targetNumber = Number(targetNumberString);\n\n  const diceRolls = getMultipleDiceRollsUntil(diceValue, explodeToSignMap[explodeType as keyof typeof explodeToSignMap], targetNumber, numberOfDice)\n\n  if (!keepType) {\n    return {...result, rolls: diceRolls, result: sumArray(diceRolls)}\n  }\n\n  return {\n    ...result,\n    rolls: diceRolls,\n    result: sumArray(applyEndModifiers(keepType as DiceKeepTypes, Number(keepCount ?? 1), diceRolls))\n  }\n}\n\nexport const rerollDiceParser = (result: ParsedDiceResultType): ParseResultType => {\n  const {m} = result\n  if (!m.match(REROLL_DICE_REGEX)) return result\n\n  const [_, numberOfDiceString, diceValueString, rerollString, operationString, rerollValueString] = REROLL_DICE_REGEX.exec(m) as RegExpExecArray\n  const numberOfDice = Number(numberOfDiceString)\n  const diceValue = Number(diceValueString)\n  const rerollValue = Number(rerollValueString)\n\n  const diceRolls = getMultipleDiceRolls(numberOfDice, diceValue)\n\n  const [rerollDiceValues, diceToSum] = getRerollValues(diceRolls, operationString as RerollCondition ?? '=', rerollValue, diceValue, rerollString)\n\n  return {\n    ...result,\n    rolls: [...diceRolls, ...rerollDiceValues],\n    rollsUsed: diceToSum,\n    result: sumArray(diceToSum)\n  }\n}\n\nexport const conditionalSubtractionParser = (result: ParsedDiceResultType): ParseResultType => {\n  const {m} = result\n  if (!m.match(CONDITIONAL_SUBTRACT_REGEX)) return result\n\n  const [_, numberOfDiceString, diceValueString, _1,  condition, targetString] = CONDITIONAL_SUBTRACT_REGEX.exec(m) as RegExpExecArray\n  const numberOfDice = Number(numberOfDiceString)\n  const diceValue = Number(diceValueString)\n  const targetValue = Number(targetString)\n\n  const diceRolls = getMultipleDiceRolls(numberOfDice, diceValue)\n\n  return {\n    ...result,\n    rolls: diceRolls,\n    result: diceRolls.reduce((acc, cur) => {\n      if (!rollMatchesTarget(cur, condition as RerollCondition, targetValue)) {\n        return acc + cur\n      }\n      return acc\n    }, 0)\n  }\n}\n\nexport const standardDiceParser = (result: ParsedDiceResultType): ParseResultType => {\n  const {m} = result\n  if (!m.match(STANDARD_DICE_REGEX)) return result\n\n  const [_, numberOfDiceString, diceValueString, keepType, keepCount] = STANDARD_DICE_REGEX.exec(m) as RegExpExecArray\n  const numberOfDice = Number(numberOfDiceString)\n  const diceValue = Number(diceValueString)\n\n  const diceRolls = getMultipleDiceRolls(numberOfDice, diceValue)\n  if (!keepType) return {...result, rolls: diceRolls, result: sumArray(diceRolls)}\n\n  return {\n    ...result,\n    rolls: diceRolls,\n    result: sumArray(applyEndModifiers(keepType as DiceKeepTypes, Number(keepCount ?? 1), diceRolls))\n  }\n}\n\nexport const parseDiceTypes = (parsedObj: ParseResultType, mappingFunction: DiceParserMappingFunction): ParseResultType => {\n  const parsedResults = parsedObj.results.map(mappingFunction)\n\n  return {...parsedObj, results: parsedResults}\n}\n\nexport const parse = (text: string): ParseResultType => {\n  let parsedObj: ParseResultType = {original: text, parsed: text, wasSuccessful: true, results: []}\n\n  try {\n    parsedObj.results = Array.from(text.matchAll(ALL_TYPES_OF_DICE_REGEX), (m) => {\n      const res = m[0]\n      const {index: start} = m\n      const end = start as number + res.length\n\n      return {m: res, start, end}\n    })\n\n    const parsingFunctionArray = [countDiceParser, explodingDiceParser, rerollDiceParser, standardDiceParser, conditionalSubtractionParser]\n\n    parsingFunctionArray.forEach((mappingFunction) => {\n      parsedObj = parseDiceTypes(parsedObj, mappingFunction)\n    })\n\n    return parseOriginalString(parsedObj)\n  } catch (error) {\n    console.error(error)\n    parsedObj.wasSuccessful = false\n    return parsedObj\n  }\n}\n","import { parse } from './parsers/Parser'\n\n(async () => {\n  const testText = `\n    1d2 1d2 1d4 1d6 1d8 1d10 1d12 1d20 1d100 2d20 20d20 200d20\n    1d10r1 2d20r<10 2d20rr<15 5d10x10 1d20x<10kh 1d20x>10kh 6d10xo10\n    3d10k 4d6k3 2d20kh 3d10kl 4d6kl3 2d20kl 3d6d 4d10d2 3d6dh 4d10min2 4d10max8\n    10d20cs20 10d20cs>10 6d10cs>=6 1d100cs<=20 3d6even 5d10cs>=6df=1\n    5d10cs>=8x=10 5d10cs>=8x>=9 10d10cs>=8x>=8 10d20cf20 10d20cf>10 6d10cf>=6\n    1d100cf<=20 4d6cs6df1 10d10cs>5df<11 1d10cs=10df=1 3d6sf<3 \n    Ana are 1d6 mere.\n    Ion a luat 1d8 slashing dmg de la sapa.\n    1d6 + 2d4\n    1d6 - 2d4\n    1d6 * 2d4\n    1d6 / 2d4\n  `\n  const result = parse(testText)\n  // console.log(result.original)\n  // console.log(result.parsed)\n  console.log(result.results)\n})()\n\nexport { }\n"],"names":["getRandomInclusive","min","max","getRandomIntegers","num","diceRollsCache","hasCache","id","_a","addToCache","values","newValues","value","getFromCache","getDiceRoll","dice","generatedValues","getMultipleDiceRolls","getDiceRollUntil","targetType","target","outArray","diceValue","iterations","getMultipleDiceRollsUntil","count","out","i","rollMatchesTarget","rolledValue","condition","rerollDice","rolledValues","rerollCondition","rerollTarget","diceType","rerolledDice","diceToSum","rolledValueKey","newRoll","recursiveRerollDice","rerolledValues","diceToSumKey","countDice","die","countType","hasDifficulty","difficultyCondition","difficultyTarget","difficultyModifier","explodeArray","explodedArray","findSmallestN","array","a","b","findGreatestN","sumArray","res","ALL_TYPES_OF_DICE_REGEX","REROLL_DICE_REGEX","EXPLODING_DICE_REGEX","COUNT_DICE_REGEX","CONDITIONAL_SUBTRACT_REGEX","STANDARD_DICE_REGEX","explodeToSignMap","keepDice","keepType","keepCount","diceRolls","applyMinMax","modifierType","modifierCap","roll","applyEndModifiers","modifier","getRerollValues","rerollType","parseOriginalString","parsedObj","parsed","results","parsedWithResults","lengthChanged","m","result","start","end","countDiceParser","_","numberOfDiceString","diceValueString","targetNumberString","difficulty","numberOfDice","targetNumber","difficultyTargetNumber","countedDice","acc","cur","explodingDiceParser","explodeType","rerollDiceParser","rerollString","operationString","rerollValueString","rerollValue","rerollDiceValues","conditionalSubtractionParser","_1","targetString","targetValue","standardDiceParser","parseDiceTypes","mappingFunction","parsedResults","parse","text","error"],"mappings":"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"}
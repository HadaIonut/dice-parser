{"version":3,"file":"index.js","sources":["../src/random-number-generators/JavascriptRandom.ts","../src/parsers/RollsProvider.ts","../src/utils/peaks.ts","../src/utils/sum.ts","../src/parsers/Parser.ts","../src/index.ts"],"sourcesContent":["import type {RandomIntegerParamsType} from '../types'\n\nconst getRandomInclusive = (min: number, max: number): number => Math.floor(Math.random() * (max - min + 1) + min)\nexport const getRandomIntegers = ({num = 20, min = 1, max = 20}: RandomIntegerParamsType = {}): number[] => Array.from({length: num}, () => getRandomInclusive(min, max))\n","import {getRandomIntegers} from '../random-number-generators/JavascriptRandom'\nimport {ExplodeUntilTypes, RerollCondition} from \"../types\";\n\nconst diceRollsCache: Map<number, number[]> = new Map<number, number[]>()\n\nconst hasCache = (id: number): boolean => diceRollsCache.has(id) && !!diceRollsCache.get(id)?.length\nconst addToCache = (id: number, values: number[]): number | undefined => {\n  const newValues = [...values]\n\n  const value = newValues.pop()\n  diceRollsCache.set(id, newValues)\n\n  return value\n}\nconst getFromCache = (id: number): number | undefined => {\n  if (!hasCache(id)) return undefined\n\n  const values: number[] = [...(diceRollsCache.get(id) || [])]\n  const value = values.pop()\n\n  diceRollsCache.set(id, values)\n  return value\n}\n\nexport const getDiceRoll = (dice: number): number => {\n  const isCached: boolean = hasCache(dice)\n  if (isCached) return getFromCache(dice) as number\n\n  const generatedValues: number[] = getRandomIntegers({max: dice})\n  return addToCache(dice, generatedValues) as number\n}\nexport const getMultipleDiceRolls = (num: number, dice: number): number[] => Array.from({length: num}, () => getDiceRoll(dice))\n\nexport const getDiceRollUntil = (dice: number, targetType: ExplodeUntilTypes, target: number, outArray: number[] = []): number[] => {\n  const diceValue = getDiceRoll(dice);\n  const iterations = [...outArray, diceValue];\n  switch (targetType) {\n    case \"<\":\n      if (diceValue >= target) return iterations\n      return getDiceRollUntil(dice, targetType, target, iterations)\n    case \">\":\n      if (diceValue <= target) return iterations\n      return getDiceRollUntil(dice, targetType, target, iterations)\n    case \"=\":\n      if (diceValue === target) return getDiceRollUntil(dice, targetType, target, iterations)\n      return iterations\n    case \"o\":\n      return [diceValue, getDiceRoll(dice)] as number[]\n  }\n}\n\nexport const getMultipleDiceRollsUntil = (dice: number, targetType: ExplodeUntilTypes, target: number, count: number) => {\n  let out: number[] = []\n  for (let i = 0; i < count; i++) {\n    out = [...out, ...getDiceRollUntil(dice, targetType, target)]\n  }\n  return out\n}\n\nexport const rollMatchesTarget = (rolledValue: number, condition: RerollCondition, target: number) => {\n  switch (condition) {\n    case \"=\":\n      return rolledValue === target;\n    case \">\":\n      return rolledValue > target;\n    case \"<\":\n      return rolledValue < target;\n    case \"<=\":\n      return rolledValue <= target;\n    case \">=\":\n      return rolledValue >= target;\n    case \"even\":\n      return rolledValue % 2 === 0\n    case \"odd\":\n      return rolledValue % 2 === 1\n  }\n}\n\nexport const rerollDice = (rolledValues: number[], rerollCondition: RerollCondition, rerollTarget: number, diceType: number) => {\n  const rerolledDice = []\n  const diceToSum = [...rolledValues]\n  for (const rolledValueKey in rolledValues) {\n    if (rollMatchesTarget(rolledValues[rolledValueKey], rerollCondition, rerollTarget)) {\n      const newRoll = getDiceRoll(diceType)\n      rerolledDice.push(newRoll)\n      diceToSum[rolledValueKey] = newRoll\n    }\n  }\n  return [rerolledDice, diceToSum]\n}\n\nexport const recursiveRerollDice = (rolledValues: number[], rerollCondition: RerollCondition, rerollTarget: number, diceType: number) => {\n  const rerolledValues = [...rolledValues]\n  let diceToSum = [...rolledValues]\n\n  for (const diceToSumKey in diceToSum) {\n    while (rollMatchesTarget(diceToSum[diceToSumKey], rerollCondition, rerollTarget)) {\n      const newRoll = getDiceRoll(diceType)\n      rerolledValues.push(newRoll)\n      diceToSum[diceToSumKey] = newRoll\n    }\n  }\n\n  return [rerolledValues, diceToSum]\n}\n\nexport const countDice = (die: number, condition: RerollCondition, countType: string, target?: number, hasDifficulty?: boolean, difficultyCondition?: RerollCondition, difficultyTarget?: number): number => {\n  const difficultyModifier = Number(rollMatchesTarget(die, difficultyCondition ?? '=', difficultyTarget ?? 0))\n  \n  if (countType === 'cs' || countType === 'cf')\n    return Math.max(Number(rollMatchesTarget(die, condition ?? '=', target ?? 0)) - difficultyModifier, -1)\n  if (countType === 'odd' || countType === 'even')\n    return Math.max(Number(rollMatchesTarget(die, countType, 0)) - difficultyModifier, -1)\n\n  return die\n}\n\nexport const explodeArray = (dice: number[], condition: RerollCondition, target: number, diceType: number) => {\n  const explodedArray = [...dice]\n\n  dice.forEach((die) => {\n    if (rollMatchesTarget(die, condition as RerollCondition, target))\n      explodedArray.push(getDiceRoll(diceType))\n  })\n\n  return explodedArray\n}\n","export const findSmallestN = (array: number[], count: number) => {\n    array.sort((a, b) =>  a - b);\n\n    return array.slice(0, count);\n}\n\nexport const findGreatestN = (array: number[], count: number) => {\n    array.sort((a, b) =>  b - a);\n\n    return array.slice(0, count);\n}","export const sumArray = (array: number[]) => array.reduce((res, num) => res + num, 0)","import type {ParseResultType, RerollCondition} from '../types'\nimport {\n  getMultipleDiceRolls,\n  getMultipleDiceRollsUntil, recursiveRerollDice,\n  rerollDice, countDice, rollMatchesTarget, getDiceRoll, explodeArray\n} from './RollsProvider'\nimport {DiceKeepTypes, ExplodeMap, ExplodeTypes, ExplodeUntilTypes, MinMaxTypes} from \"../types\";\nimport {findGreatestN, findSmallestN} from \"../utils/peaks\";\nimport {sumArray} from \"../utils/sum\";\n\nconst ALL_TYPES_OF_DICE_REGEX = /(?:\\d+d\\d+)(?:rr|r|xo|x|kh|kl|dh|dl|min|max|even|odd|cs|cf)?(?:>=|<=|>|<|=)?(\\d)*(df|x)?(>=|<=|>|<|=)?(\\d+)?/gim\nconst REROLL_DICE_REGEX = /^(\\d+)d(\\d+)(rr|r)(>=|<=|>|<)?(\\d+)$/gim\nconst EXPLODING_DICE_REGEX = /^(\\d+)d(\\d+)(x<|x>|xo|x)(\\d+)(kh|kl|dl|dh|min|max|)?(\\d+)?$/gim\nconst COUNT_DICE_REGEX = /^(\\d+)d(\\d+)(cs|cf|even|odd)(>=|<=|>|<|=)?(\\d+)?(df|x)?(>=|<=|>|<|=)?(\\d+)?$/gim\nconst STANDARD_DICE_REGEX = /^(\\d+)d(\\d+)(kh|kl|dl|dh|min|max|)?(\\d+)?$/gim\n\nconst explodeToSignMap: ExplodeMap = {\n  x: '=',\n  'x<': '<',\n  'x>': '>',\n  'xo': 'o'\n}\n\nexport const keepDice = (keepType: DiceKeepTypes, keepCount: number, diceRolls: number[]) => {\n  if (keepType === 'kh') return findGreatestN(diceRolls, keepCount)\n  if (keepType === 'kl') return findSmallestN(diceRolls, keepCount)\n  if (keepType === 'dh') return findSmallestN(diceRolls, diceRolls.length - keepCount)\n  if (keepType === 'dl') return findGreatestN(diceRolls, diceRolls.length - keepCount)\n\n  return diceRolls\n}\n\nexport const applyMinMax = (modifierType: MinMaxTypes, modifierCap: number, diceRolls: number[]) => {\n  if (modifierType === 'min') return diceRolls.map((roll) => roll <= modifierCap ? modifierCap : roll)\n  if (modifierType === 'max') return diceRolls.map((roll) => roll >= modifierCap ? modifierCap : roll)\n\n  return diceRolls\n}\n\nexport const applyEndModifiers = (modifier: DiceKeepTypes | MinMaxTypes, target: number, diceRolls: number[]) => {\n  return applyMinMax(modifier as MinMaxTypes, target, keepDice(modifier as DiceKeepTypes, target, diceRolls))\n}\n\nexport const getRerollValues = (rolledValues: number[], rerollCondition: RerollCondition, rerollTarget: number, diceType: number, rerollType: string) => {\n  if (rerollType === 'r') return rerollDice(rolledValues, rerollCondition as RerollCondition ?? '=', rerollTarget, diceType)\n  if (rerollType === 'rr') return recursiveRerollDice(rolledValues, rerollCondition as RerollCondition ?? '=', rerollTarget, diceType)\n\n  return [[], rolledValues]\n}\n\nexport const parseOriginalString = (parsedObj: ParseResultType): ParseResultType => {\n  const {parsed, results} = parsedObj\n  let parsedWithResults = parsed\n\n  let lengthChanged = 0\n  for (let i = 0; i < results.length; i++) {\n    const res = results[i];\n    const {m, result, start, end} = res\n\n    if (typeof result === 'undefined') continue\n    parsedWithResults = parsedWithResults.substring(0, start - lengthChanged)\n      + result\n      + parsedWithResults.substring(end - lengthChanged, parsedWithResults.length)\n\n    lengthChanged += m.length - `${result}`.length\n  }\n  return {...parsedObj, parsed: parsedWithResults}\n}\n\nexport const countDiceParser = (parsedObj: ParseResultType): ParseResultType => {\n  const parsedResults = parsedObj.results.map((result) => {\n    const {m} = result\n    if (!m.match(COUNT_DICE_REGEX)) return result\n\n    const [_, numberOfDiceString, diceValueString, countType, condition, targetNumberString, difficulty, difficultyCondition, difficultyTarget] = COUNT_DICE_REGEX.exec(m) as RegExpExecArray\n    const numberOfDice = Number(numberOfDiceString)\n    const diceValue = Number(diceValueString)\n    const targetNumber = Number(targetNumberString);\n    const difficultyTargetNumber = Number(difficultyTarget);\n\n    let diceRolls = getMultipleDiceRolls(numberOfDice, diceValue)\n    let countedDice\n\n    if (difficulty === 'x') {\n      diceRolls = explodeArray(diceRolls, condition as RerollCondition, difficultyTargetNumber, diceValue)\n\n      countedDice = Math.abs(diceRolls.reduce((acc, cur) =>\n        acc + countDice(cur, condition as RerollCondition, countType, targetNumber, !!difficulty, \"=\", -1), 0))\n    } else {\n      countedDice = Math.abs(diceRolls.reduce((acc, cur) =>\n        acc + countDice(cur, condition as RerollCondition, countType, targetNumber, !!difficulty, difficultyCondition as RerollCondition, difficultyTargetNumber), 0))\n    }\n\n    return {\n      ...result,\n      rolls: diceRolls,\n      successes: countedDice,\n      fails: diceRolls.length - countedDice\n    }\n  })\n\n  return {...parsedObj, results: parsedResults}\n}\n\nexport const explodingDiceParser = (parsedObj: ParseResultType): ParseResultType => {\n  const parsedResults = parsedObj.results.map((result) => {\n    const {m} = result\n    if (!m.match(EXPLODING_DICE_REGEX)) return result\n\n    const [_, numberOfDiceString, diceValueString, explodeType, targetNumberString, keepType, keepCount] = EXPLODING_DICE_REGEX.exec(m) as RegExpExecArray\n    const numberOfDice = Number(numberOfDiceString)\n    const diceValue = Number(diceValueString)\n    const targetNumber = Number(targetNumberString);\n\n    const diceRolls = getMultipleDiceRollsUntil(diceValue, explodeToSignMap[explodeType as keyof typeof explodeToSignMap], targetNumber, numberOfDice)\n\n    if (!keepType) {\n      return {...result, rolls: diceRolls, result: sumArray(diceRolls)}\n    }\n\n    return {\n      ...result,\n      rolls: diceRolls,\n      result: sumArray(applyEndModifiers(keepType as DiceKeepTypes, Number(keepCount ?? 1), diceRolls))\n    }\n  })\n\n  return {...parsedObj, results: parsedResults}\n}\n\nexport const rerollDiceParser = (parsedObj: ParseResultType): ParseResultType => {\n  const parsedResults = parsedObj.results.map((result) => {\n    const {m} = result\n    if (!m.match(REROLL_DICE_REGEX)) return result\n\n    const [_, numberOfDiceString, diceValueString, rerollString, operationString, rerollValueString] = REROLL_DICE_REGEX.exec(m) as RegExpExecArray\n    const numberOfDice = Number(numberOfDiceString)\n    const diceValue = Number(diceValueString)\n    const rerollValue = Number(rerollValueString)\n\n    const diceRolls = getMultipleDiceRolls(numberOfDice, diceValue)\n\n    const [rerollDiceValues, diceToSum] = getRerollValues(diceRolls, operationString as RerollCondition ?? '=', rerollValue, diceValue, rerollString)\n\n    return {\n      ...result,\n      rolls: [...diceRolls, ...rerollDiceValues],\n      rollsUsed: diceToSum,\n      result: sumArray(diceToSum)\n    }\n  })\n\n  return {...parsedObj, results: parsedResults}\n}\n\nexport const standardDiceParser = (parsedObj: ParseResultType): ParseResultType => {\n  const parsedResults = parsedObj.results.map((result) => {\n    const {m} = result\n    if (!m.match(STANDARD_DICE_REGEX)) return result\n\n    const [_, numberOfDiceString, diceValueString, keepType, keepCount] = STANDARD_DICE_REGEX.exec(m) as RegExpExecArray\n    const numberOfDice = Number(numberOfDiceString)\n    const diceValue = Number(diceValueString)\n\n    const diceRolls = getMultipleDiceRolls(numberOfDice, diceValue)\n    if (!keepType) return {...result, rolls: diceRolls, result: sumArray(diceRolls)}\n\n    return {\n      ...result,\n      rolls: diceRolls,\n      result: sumArray(applyEndModifiers(keepType as DiceKeepTypes, Number(keepCount ?? 1), diceRolls))\n    }\n  })\n\n  return {...parsedObj, results: parsedResults}\n}\n\nexport const parse = (text: string): ParseResultType => {\n  let parsedObj: ParseResultType = {original: text, parsed: text, wasSuccessful: true, results: []}\n\n  try {\n    parsedObj.results = Array.from(text.matchAll(ALL_TYPES_OF_DICE_REGEX), (m) => {\n      const res = m[0]\n      const {index: start} = m\n      const end = start as number + res.length\n\n      return {m: res, start, end}\n    })\n\n    parsedObj = countDiceParser(parsedObj)\n    parsedObj = explodingDiceParser(parsedObj)\n    parsedObj = rerollDiceParser(parsedObj)\n    parsedObj = standardDiceParser(parsedObj)\n\n    return parseOriginalString(parsedObj)\n  } catch (error) {\n    console.error(error)\n    parsedObj.wasSuccessful = false\n    return parsedObj\n  }\n}\n","import { parse } from './parsers/Parser'\n\n(async () => {\n  const testText = `\n    1d2 1d2 1d4 1d6 1d8 1d10 1d12 1d20 1d100 2d20 20d20 200d20\n    1d10r1 2d20r<10 2d20rr<15 5d10x10 1d20x<10kh 1d20x>10kh 6d10xo10 5d10xo<8x10cs>=8\n    3d10k 4d6k3 2d20kh 3d10kl 4d6kl3 2d20kl 3d6d 4d10d2 3d6dh 4d10min2 4d10max8\n    10d20cs20 10d20cs>10 6d10cs>=6 1d100cs<=20 3d6even 5d10cs>=6df=1\n    5d10cs>=8x=10 5d10cs>=8x>=9 10d10cs>=8x>=8 10d20cf20 10d20cf>10 6d10cf>=6\n    1d100cf<=20 4d6cs6df1 10d10cs>5df<11 1d10cs=10df=1 3d6sf<3 3d6ms10\n    Ana are 1d6 mere.\n    Ion a luat 1d8 slashing dmg de la sapa.\n    1d6 + 2d4\n  `\n  const result = parse(testText)\n  // console.log(result.original)\n  // console.log(result.parsed)\n  console.log(result.results)\n})()\n\nexport { }\n"],"names":["getRandomInclusive","min","max","getRandomIntegers","num","diceRollsCache","hasCache","id","_a","addToCache","values","newValues","value","getFromCache","getDiceRoll","dice","generatedValues","getMultipleDiceRolls","getDiceRollUntil","targetType","target","outArray","diceValue","iterations","getMultipleDiceRollsUntil","count","out","i","rollMatchesTarget","rolledValue","condition","rerollDice","rolledValues","rerollCondition","rerollTarget","diceType","rerolledDice","diceToSum","rolledValueKey","newRoll","recursiveRerollDice","rerolledValues","diceToSumKey","countDice","die","countType","hasDifficulty","difficultyCondition","difficultyTarget","difficultyModifier","explodeArray","explodedArray","findSmallestN","array","a","b","findGreatestN","sumArray","res","ALL_TYPES_OF_DICE_REGEX","REROLL_DICE_REGEX","EXPLODING_DICE_REGEX","COUNT_DICE_REGEX","STANDARD_DICE_REGEX","explodeToSignMap","keepDice","keepType","keepCount","diceRolls","applyMinMax","modifierType","modifierCap","roll","applyEndModifiers","modifier","getRerollValues","rerollType","parseOriginalString","parsedObj","parsed","results","parsedWithResults","lengthChanged","m","result","start","end","countDiceParser","parsedResults","_","numberOfDiceString","diceValueString","targetNumberString","difficulty","numberOfDice","targetNumber","difficultyTargetNumber","countedDice","acc","cur","explodingDiceParser","explodeType","rerollDiceParser","rerollString","operationString","rerollValueString","rerollValue","rerollDiceValues","standardDiceParser","parse","text","error"],"mappings":"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"}
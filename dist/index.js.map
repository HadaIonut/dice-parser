{"version":3,"file":"index.js","sources":["../src/random-number-generators/JavascriptRandom.ts","../src/parsers/RollsProvider.ts","../src/utils/peaks.ts","../src/utils/sum.ts","../src/parsers/Parser.ts","../src/index.ts"],"sourcesContent":["import type {RandomIntegerParamsType} from '../types'\n\nconst getRandomInclusive = (min: number, max: number): number => Math.floor(Math.random() * (max - min + 1) + min)\nexport const getRandomIntegers = ({num = 20, min = 1, max = 20}: RandomIntegerParamsType = {}): number[] => Array.from({length: num}, () => getRandomInclusive(min, max))\n","import {getRandomIntegers} from '../random-number-generators/JavascriptRandom'\nimport {ExplodeUntilTypes, RerollCondition} from \"../types\";\n\nconst diceRollsCache: Map<number, number[]> = new Map<number, number[]>()\n\nconst hasCache = (id: number): boolean => diceRollsCache.has(id) && !!diceRollsCache.get(id)?.length\nconst addToCache = (id: number, values: number[]): number | undefined => {\n  const newValues = [...values]\n\n  const value = newValues.pop()\n  diceRollsCache.set(id, newValues)\n\n  return value\n}\nconst getFromCache = (id: number): number | undefined => {\n  if (!hasCache(id)) return undefined\n\n  const values: number[] = [...(diceRollsCache.get(id) || [])]\n  const value = values.pop()\n\n  diceRollsCache.set(id, values)\n  return value\n}\n\nexport const getDiceRoll = (dice: number): number => {\n  const isCached: boolean = hasCache(dice)\n  if (isCached) return getFromCache(dice) as number\n\n  const generatedValues: number[] = getRandomIntegers({max: dice})\n  return addToCache(dice, generatedValues) as number\n}\nexport const getMultipleDiceRolls = (num: number, dice: number): number[] => Array.from({length: num}, () => getDiceRoll(dice))\n\nexport const getDiceRollUntil = (dice: number, targetType: ExplodeUntilTypes, target: number, outArray: number[] = []): number[] => {\n  const diceValue = getDiceRoll(dice);\n  const iterations = [...outArray, diceValue];\n  switch (targetType) {\n    case \"<\":\n      if (diceValue >= target) return iterations\n      return getDiceRollUntil(dice, targetType, target, iterations)\n    case \">\":\n      if (diceValue <= target) return iterations\n      return getDiceRollUntil(dice, targetType, target, iterations)\n    case \"=\":\n      if (diceValue === target) return getDiceRollUntil(dice, targetType, target, iterations)\n      return iterations\n    case \"o\":\n      return [diceValue, getDiceRoll(dice)] as number[]\n  }\n}\n\nexport const getMultipleDiceRollsUntil = (dice: number, targetType: ExplodeUntilTypes, target: number, count: number) => {\n  let out: number[] = []\n  for (let i = 0; i < count; i++) {\n    out = [...out, ...getDiceRollUntil(dice, targetType, target)]\n  }\n  return out\n}\n\nconst rollMatchesTarget = (rolledValue: number, rerollCondition: RerollCondition, rerollTarget: number) => {\n  switch (rerollCondition) {\n    case \"=\":\n      return rolledValue === rerollTarget;\n    case \">\":\n      return rolledValue < rerollTarget;\n    case \"<\":\n      return rolledValue > rerollTarget;\n    case \"<=\":\n      return rolledValue >= rerollTarget;\n    case \">=\":\n      return rolledValue <= rerollTarget;\n  }\n}\n\nconst rollArrayMatchesTarget = (rolledValues: number[], rerollCondition: RerollCondition, rerollTarget: number) =>\n  rolledValues.every((rolledValue) => {\n    console.log(rolledValue, rollMatchesTarget(rolledValue, rerollCondition, rerollTarget), rerollCondition, rerollTarget)\n    return rollMatchesTarget(rolledValue, rerollCondition, rerollTarget)\n  })\n\nexport const rerollDice = (rolledValues: number[], rerollCondition: RerollCondition, rerollTarget: number, diceType: number) => {\n  const rerolledDice = []\n  const diceToSum = [...rolledValues]\n  for (const rolledValueKey in rolledValues) {\n    if (rollMatchesTarget(rolledValues[rolledValueKey], rerollCondition, rerollTarget)) {\n      const newRoll = getDiceRoll(diceType)\n      rerolledDice.push(newRoll)\n      diceToSum[rolledValueKey] = newRoll\n    }\n  }\n  return [rerolledDice, diceToSum]\n}\n\n","export const findSmallestN = (array: number[], count: number) => {\n    array.sort((a, b) =>  a - b);\n\n    return array.slice(0, count);\n}\n\nexport const findGreatestN = (array: number[], count: number) => {\n    array.sort((a, b) =>  b - a);\n\n    return array.slice(0, count);\n}","export const sumArray = (array: number[]) => array.reduce((res, num) => res + num, 0)","import type {ParseResultType, RerollCondition} from '../types'\nimport {\n  getMultipleDiceRolls,\n  getMultipleDiceRollsUntil,\n  rerollDice\n} from './RollsProvider'\nimport {DiceKeepTypes, ExplodeMap, ExplodeTypes, ExplodeUntilTypes} from \"../types\";\nimport {findGreatestN, findSmallestN} from \"../utils/peaks\";\nimport {sumArray} from \"../utils/sum\";\n\nconst ALL_TYPES_OF_DICE_REGEX = /(?:\\d+d\\d+)(?:rr|r|xo|x|kh|kl|dh|dl|min|max|even|odd|cs|cf)?(?:>=|<=|>|<|=)?\\d*/gim\nconst REROLL_DICE_REGEX = /^(\\d+)d(\\d+)(rr|r)(>=|<=|>|<)?(\\d+)$/gim\nconst EXPLODING_DICE_REGEX = /^(\\d+)d(\\d+)(x<|x>|xo|x)(\\d+)(kh|kl|dl|dh)?(\\d+)?$/gim\nconst STANDARD_DICE_REGEX = /^(\\d+)d(\\d+)(kh|kl|dl|dh)?(\\d+)?$/gim\n\nconst explodeToSignMap: ExplodeMap = {\n  x: '=',\n  'x<': '<',\n  'x>': '>',\n  'xo': 'o'\n}\n\nexport const parseOriginalString = (parsedObj: ParseResultType): ParseResultType => {\n  const {parsed, results} = parsedObj\n  let parsedWithResults = parsed\n\n  let lengthChanged = 0\n  for (let i = 0; i < results.length; i++) {\n    const res = results[i];\n    const {m, result, start, end} = res\n\n    if (typeof result === 'undefined') continue\n    parsedWithResults = parsedWithResults.substring(0, start - lengthChanged)\n      + result\n      + parsedWithResults.substring(end - lengthChanged, parsedWithResults.length)\n\n    lengthChanged += m.length - `${result}`.length\n  }\n  return {...parsedObj, parsed: parsedWithResults}\n}\n\nexport const rerollDiceParser = (parsedObj: ParseResultType): ParseResultType => {\n  const parsedResults = parsedObj.results.map((result) => {\n    const {m} = result\n    if (!m.match(REROLL_DICE_REGEX)) return result\n\n    const [_, numberOfDiceString, diceValueString, rerollString, operationString, rerollValueString] = REROLL_DICE_REGEX.exec(m) as RegExpExecArray\n    const numberOfDice = Number(numberOfDiceString)\n    const diceValue = Number(diceValueString)\n    const rerollValue = Number(rerollValueString)\n\n    const diceRolls = getMultipleDiceRolls(numberOfDice, diceValue)\n\n    if (rerollString === 'r') {\n      const [rerollDiceValues, diceToSum] = rerollDice(diceRolls, operationString as RerollCondition ?? '=', rerollValue, diceValue)\n\n      return {\n        ...result,\n        rolls: [...diceRolls, ...rerollDiceValues],\n        rollsUsed: diceToSum,\n        result: sumArray(diceToSum)\n      }\n    } else if (rerollString === 'rr') {\n      // const allRerolls = recursiveRerollDice(diceRolls, operationString as RerollCondition, rerollValue, diceValue)\n      //\n      // return {\n      //   ...result,\n      //   rolls: allRerolls,\n      //   rollsUsed: allRerolls.slice(-numberOfDice),\n      //   result: 0\n      // }\n    }\n\n    return {...result, rolls: diceRolls, result: sumArray(diceRolls)}\n  })\n\n  return {...parsedObj, results: parsedResults}\n}\n\nexport const standardDiceParser = (parsedObj: ParseResultType): ParseResultType => {\n  const parsedResults = parsedObj.results.map((result) => {\n    const {m} = result\n    if (!m.match(STANDARD_DICE_REGEX)) return result\n\n    const [_, numberOfDiceString, diceValueString, keepType, keepCount] = STANDARD_DICE_REGEX.exec(m) as RegExpExecArray\n    const numberOfDice = Number(numberOfDiceString)\n    const diceValue = Number(diceValueString)\n\n    const diceRolls = getMultipleDiceRolls(numberOfDice, diceValue)\n    if (!keepType) return {...result, rolls: diceRolls, result: sumArray(diceRolls)}\n\n    return {\n      ...result,\n      rolls: diceRolls,\n      result: sumArray(keepDice(keepType as DiceKeepTypes, Number(keepCount ?? 1), diceRolls))\n    }\n  })\n\n  return {...parsedObj, results: parsedResults}\n}\n\nexport const keepDice = (keepType: DiceKeepTypes, keepCount: number, diceRolls: number[]) => {\n  if (keepType === 'kh') return findGreatestN(diceRolls, keepCount)\n  if (keepType === 'kl') return findSmallestN(diceRolls, keepCount)\n  if (keepType === 'dh') return findSmallestN(diceRolls, diceRolls.length - keepCount)\n  if (keepType === 'dl') return findGreatestN(diceRolls, diceRolls.length - keepCount)\n\n  return diceRolls\n}\n\nexport const explodingDiceParser = (parsedObj: ParseResultType): ParseResultType => {\n  const parsedResults = parsedObj.results.map((result) => {\n    const {m} = result\n    if (!m.match(EXPLODING_DICE_REGEX)) return result\n\n    const [_, numberOfDiceString, diceValueString, explodeType, targetNumberString, keepType, keepCount] = EXPLODING_DICE_REGEX.exec(m) as RegExpExecArray\n    const numberOfDice = Number(numberOfDiceString)\n    const diceValue = Number(diceValueString)\n    const targetNumber = Number(targetNumberString);\n\n    const diceRolls = getMultipleDiceRollsUntil(diceValue, explodeToSignMap[explodeType as keyof typeof explodeToSignMap], targetNumber, numberOfDice)\n\n    if (!keepType) {\n      return {...result, rolls: diceRolls, result: sumArray(diceRolls)}\n    }\n\n    return {\n      ...result,\n      rolls: diceRolls,\n      result: sumArray(keepDice(keepType as DiceKeepTypes, Number(keepCount ?? 1), diceRolls))\n    }\n  })\n\n  return {...parsedObj, results: parsedResults}\n}\n\nexport const parse = (text: string): ParseResultType => {\n  let parsedObj: ParseResultType = {original: text, parsed: text, wasSuccessful: true, results: []}\n\n  try {\n    parsedObj.results = Array.from(text.matchAll(ALL_TYPES_OF_DICE_REGEX), (m) => {\n      const res = m[0]\n      const {index: start} = m\n      const end = start as number + res.length\n\n      return {m: res, start, end}\n    })\n\n    parsedObj = explodingDiceParser(parsedObj)\n    parsedObj = rerollDiceParser(parsedObj)\n    parsedObj = standardDiceParser(parsedObj)\n\n    return parseOriginalString(parsedObj)\n  } catch (error) {\n    console.error(error)\n    parsedObj.wasSuccessful = false\n    return parsedObj\n  }\n}\n","import { parse } from './parsers/Parser'\n\n(async () => {\n  const testText = `\n    1d2 1d2 1d4 1d6 1d8 1d10 1d12 1d20 1d100 2d20 20d20 200d20\n    1d10r1 2d20r<10 2d20rr<15 5d10x10 1d20x<10kh 1d20x>10kh 6d10xo10 5d10xo<8x10cs>=8\n    3d10k 4d6k3 2d20kh 3d10kl 4d6kl3 2d20kl 3d6d 4d10d2 3d6dh 4d10min2 4d10max8\n    10d20cs20 10d20cs>10 6d10cs>=6 1d100cs<=20 3d6even 5d10cs>=6df=1\n    5d10cs>=8x=10 5d10cs>=8x>=9 10d10cs>=8x>=8 10d20cf20 10d20cf>10 6d10cf>=6\n    1d100cf<=20 4d6cs6df1 10d10cs>5df1 1d10cs=10df=1 3d6sf<3 3d6ms10\n    Ana are 1d6 mere.\n    Ion a luat 1d8 slashing dmg de la sapa.\n    1d6 + 2d4\n  `\n  const result = parse(testText)\n  // console.log(result.original)\n  // console.log(result.parsed)\n  console.log(result.results)\n})()\n\nexport { }\n"],"names":["getRandomInclusive","min","max","getRandomIntegers","num","diceRollsCache","hasCache","id","_a","addToCache","values","newValues","value","getFromCache","getDiceRoll","dice","generatedValues","getMultipleDiceRolls","getDiceRollUntil","targetType","target","outArray","diceValue","iterations","getMultipleDiceRollsUntil","count","out","i","rollMatchesTarget","rolledValue","rerollCondition","rerollTarget","rerollDice","rolledValues","diceType","rerolledDice","diceToSum","rolledValueKey","newRoll","findSmallestN","array","a","b","findGreatestN","sumArray","res","ALL_TYPES_OF_DICE_REGEX","REROLL_DICE_REGEX","EXPLODING_DICE_REGEX","STANDARD_DICE_REGEX","explodeToSignMap","parseOriginalString","parsedObj","parsed","results","parsedWithResults","lengthChanged","m","result","start","end","rerollDiceParser","parsedResults","_","numberOfDiceString","diceValueString","rerollString","operationString","rerollValueString","numberOfDice","rerollValue","diceRolls","rerollDiceValues","standardDiceParser","keepType","keepCount","keepDice","explodingDiceParser","explodeType","targetNumberString","targetNumber","parse","text","error"],"mappings":"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"}